<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        svg{
            border: 1px solid;
        }
    </style>
</head>
<body>
    <script src="../lib/d3.min.js"></script>
    <script>
        const h = 300;
        const l = 600

        const svg = d3.select("body")
            .append("svg")
            .attr("width",h)
            .attr("height",l)

        /*
        Attention : données nettoyées avec expression régulière
            recherche : "([0-9]+),([0-9]+),([0-9]+)"
            remplacement : "$1$2$3"
            
            recherche : "([0-9]+),([0-9]+)"
            remplacement : "$1$2"
        */

        // helper pour convertir le mois en nombre
        function mois_en_numerique(m){
            switch(m){
                case "January": return "1"
                case "February" : return "2"
                case "March" : return "3"
                case "April" : return "4"
                case "May" : return "5"
                case "June" : return "6"
                case "July" : return "7"
                case "August" : return "8"
                case "September" : return "9"
                case "October" : return "10"
                case "November" : return "11"
                case "December" : return "12"
                default : return "erreur"           
            }
        }

        let selection = d3.csv("../data/rpg_steam_clean.csv", d => {
            return {
                // nous travaillons avec moins de données
                mois_sortie : mois_en_numerique(d.release_month),
                annee_sortie : +d.release_year,
            }
        }).then(jeux => {
            // let t = [];
            // // créer un objet contenant les propriétés recherchées
            // for(let m = 0; i< jeux.mois_sortie.length; m++){
            //     for(let a = 0; a< jeux.annee_sortie.length; a++){
            //         let o = {mois_sortie : jeux.mois_sortie}
            //     }                
            // }

            let map_mois_annees = d3.rollup(jeux, d => d.length, d => d.mois_sortie, d => d.annee_sortie)
            console.log(map_mois_annees);

            for(m of map_mois_annees.entries()){
                console.log("m",m)
            }

        // [{mois_sortie : 1, annee_sortie : 2019, total : 23}]
            
            // // vérification des données produites
            // console.log("Données construites : ",jeux);
            // // préparer la map avec un rollup
            // let map_mois_annees = d3.rollup(jeux, d => d.length, d => d.mois_sortie, d => d.annee_sortie)

            // for (let m of map_mois_annees){
            //     console.log("ESSAI",m.get("10"))
            // }

            // const mma = map_mois_annees.map(v => {
            //     return v.get(10)
            // })
            //console.log("mma",mma)

            // console.log("map_mois_annees :",map_mois_annees)
            // créer l'objet de la forme
            // [{mois_sortie : 1, annee_sortie : 2019, total : 23}]
            // for (let m of map_mois_annees){
            //     for(let n of m){
            //         console.log(n)
            //     }
            // }

            // const final = [];

            // for (let m of map_mois_annees){
            //     let mois = m[0];
            //     console.log(m)
            // }
            //console.log("final",final)
            


            // ici on ne peut pas récupérer les données directement, sans quoi elles ne seront pas ordonnées comme attendu : exemple
            
            // récupération de la liste des mois et tri par ordre alphabétique
            const liste_mois_complete = jeux.map(j => j.mois_sortie).sort(d3.ascending);
            // extraction d'une liste unique avec un set
            const liste_mois_unique = [...new Set(liste_mois_complete)];
            console.log(liste_mois_unique)
            console.log(liste_mois_complete)

            // on doit donc la créer nous-même, soit
            // soit au format textuel...
            const ma_liste_mois = ["janvier","février","mars","avril","mai","juin","juillet","août","septembre","octobre","novembre","décembre"];
            // soit au format numérique...
            const ma_liste_no_mois = d3.range(1,13);

            // récupération de la liste des années
            const liste_annees_complete = jeux.map(j => j.annee_sortie);
            // extraction d'une liste unique avec un set
            const liste_annees_unique = [...new Set(liste_annees_complete)].sort(d3.ascending);
            
            /* CONSTRUCTION DES ECHELLES ET DES AXES */

            // nous devons maintenant convertir nos données pour atteindre la forme
            // {année : valeur, mois : valeur, total : valeur}
            // où total vaut 

            // construction de l'échelle des x
            const x = d3.scaleBand()
            .range([ 0, l ])
            .domain(liste_mois_unique)
            .padding(0.01);

            // ajout de l'axe des x
            svg.append("g")
            .attr("transform", `translate(0, ${h})`)
            .call(d3.axisBottom(x))

            // construction de l'échelle des y
            const y = d3.scaleBand()
            .range([ h, 0 ])
            .domain(liste_annees_unique)
            .padding(0.01);

            // ajout de l'axe des y
            svg.append("g")
            .call(d3.axisLeft(y));

            // préparer l'échelle de couleurs
            const couleurs = d3.scaleLinear()
            .range(["white", "#69b3a2"])
            .domain([1,100])

            // joindre les données
            svg.selectAll()
                .data(jeux, j => j.mois_sortie+':'+j.annee_sortie)
                .join("rect")
                    .attr("x", j => x(j.mois_sortie))
                    .attr("y", j => y(j.annee_sortie))
                    .attr("width", x.bandwidth() )
                    .attr("height", y.bandwidth() )
                    .style("fill", j => couleurs(60))      
        })

    </script>
</body>
</html>